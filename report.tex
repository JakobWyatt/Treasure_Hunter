\documentclass{article}

\usepackage{lmodern}  % for bold teletype font
\usepackage{amsmath}  % for \hookrightarrow
\usepackage{xcolor}   % for \textcolor
\usepackage{listings}

\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  frame=single,
  breaklines=true,
  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
}

\title{UCP Report}
\date{\today}
\author{Jakob Wyatt}

\begin{document}

\maketitle
\pagebreak
\tableofcontents
\pagebreak

\section{Purpose of Functions}

\subsection{resolveAdventure}
\begin{lstlisting}
status resolveAdventure(map items, unsigned long rows, unsigned long cols, list movements, explorer* person, FILE* file);
\end{lstlisting}


 Resolve an adventure, given a map and a list of movements.\\ 
 \texttt{items} Map containing all items.\\ 
 \texttt{rows} Number of rows in the map.\\ 
 \texttt{cols} Number of columns in the map.\\ 
 \texttt{movements} Movements to be made by the explorer.\\ 
 \texttt{person} Explorer to collect items.\\ 
 \texttt{file} File to write logs to.\\ 
 \textbf{Return:} SUCCESS if the adventure was sucessful,
         CORRECTED if out of bounds movements were corrected,
         FAILED if out of bounds movements weren't corrected.\\ 
 \textbf{Precondition:}  file must be opened in "a" mode.\\ 
 \textbf{Postcondition:}  items is modified when  treasure is picked up by  person.\\ 
 \textbf{Postcondition:}  items and  movements are not deallocated by this function.
 Define AI to correct out of bounds movements.
         Define LOG to log movements to stdout as well as  file.\\
 \textbf{Implementation:}
Iterate through the list of movements, and keep track of the current location of  person.
This is done in 2 steps:
    \begin{enumerate}
     \item Get the next movement from the list, and calculate the final block  person will be on after this movement.
         This is done with  endBlock.
     \item Travel in the direction of the movement using  moveDist until the final block is reached.
         Treasures are collected and logged with  collectAndLog. 
    \end{enumerate}
 This is done until  movements is exhausted or an error status is set.


\subsection{collectAndLog}
\begin{lstlisting}
void collectAndLog(FILE* file, map items, explorer* person, long i, long j);
\end{lstlisting}


 Collects the treasure at the given location. Logs this event to a file.\\ 
 \texttt{file} File to log information to.\\ 
 \texttt{items} Map containing item to collect.\\ 
 \texttt{person} Explorer to collect the item.\\ 
 \texttt{i} y location of the treasure to collect.\\ 
 \texttt{j} x location of the treasure to collect.\\ 
 \textbf{Precondition:}  file must be opened in "a" mode.\\ 
 \textbf{Postcondition:} The treasure in items is either swapped, destroyed (and deallocated), or retained.\\ 
 
 
 \textbf{Implementation:}
Switch on the type of the treasure.
coin: Deallocate and increase  explorer.coin by  treasure.value.
magic: Deallocate and increase  explorer.magic by  treasure.value.
gear: Use  treasure.compare to compare and conditionally swap the two treasures.
Log with  logTreasure if any deallocation or swapping occured.


\subsection{logTreasure}
\begin{lstlisting}
void logTreasure(FILE* file, treasure x, int collect, long i, long j);
\end{lstlisting}


 Logs a treasure to a file, and optionally stdout.\\ 
 \texttt{file} File to log information to.\\ 
 \texttt{x} Treasure to log.\\ 
 \texttt{collect} If  collect == 0, then log  x as collected.
     Else, log it as discarded.\\ 
 \texttt{i} y location of the treasure.\\ 
 \texttt{j} x location of the treasure.\\ 
 \textbf{Precondition:}  file must be opened in "a" mode.
 Define LOG to write the information to stdout as well as  file.\\ 
 
 
 \textbf{Implementation:}
Switch on  x.type, and log the treasure according to the assignment specification.


\subsection{endBlock}
\begin{lstlisting}
status endBlock(unsigned long rows, unsigned long cols, long* i, long* j, move x);
\end{lstlisting}


 Finds the final block after a movement is performed.\\ 
 \texttt{rows} The number of rows in the map.\\ 
 \texttt{cols} The number of cols in the map.\\ 
 \texttt{i} The starting y location. Exports the new y location.\\ 
 \texttt{j} The starting x location. Exports the new x location.\\ 
 \texttt{x} The movement direction and distance.\\ 
 \textbf{Return:} SUCCESS if the movement was performed correctly,
         CORRECTED if the movement was corrected,
         FAILED if the movement is out of bounds.
 Define AI to correct out of bounds movements.\\ 
 
 
 \textbf{Implementation:}
Move the given distance with  move\_dist.
If AI is defined, correct the location if out of bounds.
If the distance is still out of bounds, return FAILED.


\subsection{move\_dist}
\begin{lstlisting}
void move_dist(direction dir, unsigned long distance, long* i, long* j);
\end{lstlisting}


 Moves a given distance in a given direction.\\ 
 \texttt{dir} The direction to move.\\ 
 \texttt{distance} The distance to move.\\ 
 \texttt{i} The starting y location. Exports the new y location.\\ 
 \texttt{j} The starting x location. Exports the new x location.\\ 
 \textbf{Postcondition:} Does not check if the distance is valid.\\ 
 
 
 \textbf{Implementation:}
Depending on the direction, change the relevant coordinate.


\subsection{insert}
\begin{lstlisting}
void insert(list* x, node* iter, void* data);
\end{lstlisting}


  Insert an element into a linked list.\\ 
 \texttt{x} The list to insert into.\\ 
 \texttt{iter} Insert before this element. If  iter is NULL,
     insert at the end of the list.\\ 
 \texttt{data} The pointer to data that will be stored by the node.\\ 
 
 
 \textbf{Implementation:}
 A node named new is dynamically allocated (on the heap),
     and  data is referenced by it.
     \begin{itemize}
 \item If  iter == NULL, insert at the end of the list.
    \begin{enumerate}
     \item Node before new is  x$\rightarrow$tail.
     \item Node after new is NULL.
     \item  x$\rightarrow$tail is now new.
     \item If there are currently no elements in the list,
             set x$\rightarrow$head to new. Otherwise, link the node before
             new to new.
    \end{enumerate}
 \item Otherwise, the next node is guarenteed to exist.
    \begin{enumerate}
     \item Node before new is  iter$\rightarrow$prev.
     \item Node after new is iter.
     \item  iter$\rightarrow$prev is new.
     \item If iter$\rightarrow$prev is NULL (start of list),  x$\rightarrow$head is new.
         Otherwise, new$\rightarrow$prev$\rightarrow$next is new.
    \end{enumerate}
 \end{itemize}

\subsection{remove\_node}
\begin{lstlisting}
void remove_node(list* x, node* iter);
\end{lstlisting}


  Remove a node from a linked list.\\ 
 \texttt{x} The list to remove the node from.\\ 
 \texttt{iter} The node to remove.
  Calls  free() on  iter.data\\ 
 
 
 \textbf{Implementation:}
First, free  iter$\rightarrow$data.
If  iter is the first element in  x,
 change the head pointer to  iter$\rightarrow$next.
Otherwise, the previous node.next is equal to the
 next node.
When  iter is the final element in  x,
 perform the algorithm above but set the tail pointer
 and the next node.prev instead.
 

\subsection{make\_list}
\begin{lstlisting}
list make_list();
\end{lstlisting}


  Initializes an empty list.\\ 
 \textbf{Return:} The empty list.
  The list struct is statically allocated (on the stack).\\ 
 
 
 \textbf{Implementation:}
Set head and tail to NULL.
 

\subsection{free\_list}
\begin{lstlisting}
void free_list(list* x);
\end{lstlisting}


  Free all elements in the list.\\ 
 \texttt{x} The list to free.
  Calls  free() on  node.data for all nodes.\\ 
 
 
 \textbf{Implementation:}
Call  remove\_node on  x$\rightarrow$head until x$\rightarrow$head is NULL (list is empty).
 

\subsection{for\_each}
\begin{lstlisting}
void for_each(list x, data_func func);
\end{lstlisting}


  Applies a function to every  node in the  list.\\ 
 \texttt{x} The list to apply  func to.\\ 
 \texttt{func} The function to apply to every node.
   func is called on each  node in order.\\ 
 
 
 \textbf{Implementation:}
 \begin{enumerate}
\item Apply  func to the current node, starting at  x.head.
\item Move the current node forward.
\end{enumerate}
Repeat this until the current node is NULL.
 

\section{Conversion of Input File to Coordinate System}
\subsection{Implementation}
The top level function to convert the input file is read\_map.
This function opens the file, reads and validates the map size (rows and columns),
and uses allocate\_map to allocate memory for the map.

Once this is done, fill\_map is called.
This function parses the file line by line, and reads values into the map.
First, read\_line is called. This function reads a line of arbitrary size
by reallocating larger buffers until the line is read in full. This means that
the map can be as large as the user wants.
Once the line is read, it is split into tokens using split. This function iterates
over the provided string, finds a given delimiter (',' in this case) with strchr, and substitutes
it will a null-terminator. It then exports an array filled with pointers to the start
of each token. This has the effect of breaking a string up into many substrings, seperated
by the delimiter.

Once this is done, each individual token is passed to make\_treasure. This function
uses a switch statement on the first character to determine the type of the treasure.
Once the type is determined, the treasure is usually parsed by finding the colon character(s)
with strchr, and either using strncpy or sscanf to parse each section.
In the case of a gear treasure,
the function chooseCompareFunc is used to determine which function pointer should be used
with the given slot.

\subsection{Alternate Implementation}

An alternate approach would be to either use strtok, or the given tokenizer, to parse each line.
This would mean that make\_treasure would be passed tokens one at a time, rather than splitting the entire
string and then passing all tokens to make\_treasure. This method was not chosen, as strtok ignores repeated
characters and is therefore unsuitable for any empty sections of the map. strtok could also be used to parse
individual treasures, instead of using strchr.


\section{Sample Input and Output}
All test results are generated from the TreasureHunter binary.
This is called with the arguments:
\begin{lstlisting}
    ./TreasureHunter <map file> <list file>
\end{lstlisting}
A script to run these tests is located in test/all\_tests.sh.
There is no user input for any test cases.
If example output from adventure.log is not provided, it should be assumed that the binary
does not provide log file output for that test case.

The TreasureHunterLog binary will produce the same output as the TreasureHunter binary,
except any output to the log file (adventure.log) is also output to stdout. This is done
real time; as lines are printed to the log file, the same content is printed to stdout.

The TreasureHunterAI binary is assumed to produce the same output as the TreasureHunter binary,
unless otherwise stated.

\subsection{Example Input from Assignment Brief}
\quad \textbf{Map}
\begin{lstlisting}
5,4
,,C 200,
,G Vibranium Shield:hands:990,,C 50
M Healing Potion:85,,M Defence Enchantment:360,
,,,
,,G Lightsaber:hands:850,
\end{lstlisting}

\textbf{List}
\begin{lstlisting}
DOWN 2
RIGHT 2
DOWn 2
up 0
LEFT 1
UP 3
riGHT 0
RIGHT 2
\end{lstlisting}
\pagebreak

\textbf{stdout}
\begin{lstlisting}
STATUS: COMPLETE
COINS: 50
MAGIC: 445
GEAR: 990
\end{lstlisting}

\textbf{Log file}
\begin{lstlisting}
---
COLLECT<ITEM:MAGIC, XLOC:2, YLOC:0, DESCRIPTION:Healing Potion, VALUE:85>
COLLECT<ITEM:MAGIC, XLOC:2, YLOC:2, DESCRIPTION:Defence Enchantment, VALUE:360>
COLLECT<ITEM:GEAR, XLOC:4, YLOC:2, DESCRIPTION:Lightsaber, SLOT:hands, VALUE:850>
COLLECT<ITEM:GEAR, XLOC:1, YLOC:1, DESCRIPTION:Vibranium Shield, SLOT:hands, VALUE:990>
DISCARD<ITEM:GEAR, XLOC:1, YLOC:1, DESCRIPTION:Lightsaber, SLOT:hands, VALUE:850>
COLLECT<ITEM:COINS, XLOC:1, YLOC:3, VALUE:50>
\end{lstlisting}

\subsection{Out of Bounds}
\subsubsection{TreasureHunter}
\quad \textbf{Map}
\begin{lstlisting}
7,3
,g Thorn armour:CheST:120,C 200
,G Vibranium Shield:hands:990,
M Healing Potion:85,,M Defence Enchantment:360
,m Phoenix Blood:291,
,g IDEK_ANYMORE:heaD:21,G Lightsaber:hAnDs:850
c 350,g Crimson Plate:cHeSt:1020,
,G Infinity Pants:leGS:30000,
\end{lstlisting}

\textbf{List}
\begin{lstlisting}
LEFt 3
RIGHT 1
down 2
LEfT 5
RIGHT 20
left 1
DOWN 100
UP 2000
\end{lstlisting}
\pagebreak

\textbf{stdout}
\begin{lstlisting}
STATUS: FAILED
\end{lstlisting}

\textbf{Log file}
\begin{lstlisting}
---
\end{lstlisting}

\subsubsection{TreasureHunterAI}
\quad \textbf{Map}
\begin{lstlisting}
7,3
,g Thorn armour:CheST:120,C 200
,G Vibranium Shield:hands:990,
M Healing Potion:85,,M Defence Enchantment:360
,m Phoenix Blood:291,
,g IDEK_ANYMORE:heaD:21,G Lightsaber:hAnDs:850
c 350,g Crimson Plate:cHeSt:1020,
,G Infinity Pants:leGS:30000,
\end{lstlisting}

\textbf{List}
\begin{lstlisting}
LEFt 3
RIGHT 1
down 2
LEfT 5
RIGHT 20
left 1
DOWN 100
UP 2000
\end{lstlisting}
\pagebreak

\textbf{stdout}
\begin{lstlisting}
STATUS: CORRECTED
COINS: 0
MAGIC: 736
GEAR: 32031
\end{lstlisting}

\textbf{Log file}
\begin{lstlisting}
---
COLLECT<ITEM:GEAR, XLOC:0, YLOC:1, DESCRIPTION:Thorn armour, SLOT:chest, VALUE:120>
COLLECT<ITEM:GEAR, XLOC:1, YLOC:1, DESCRIPTION:Vibranium Shield, SLOT:hands, VALUE:990>
COLLECT<ITEM:MAGIC, XLOC:2, YLOC:0, DESCRIPTION:Healing Potion, VALUE:85>
COLLECT<ITEM:MAGIC, XLOC:2, YLOC:2, DESCRIPTION:Defence Enchantment, VALUE:360>
COLLECT<ITEM:MAGIC, XLOC:3, YLOC:1, DESCRIPTION:Phoenix Blood, VALUE:291>
COLLECT<ITEM:GEAR, XLOC:4, YLOC:1, DESCRIPTION:IDEK_ANYMORE, SLOT:head, VALUE:21>
COLLECT<ITEM:GEAR, XLOC:5, YLOC:1, DESCRIPTION:Crimson Plate, SLOT:chest, VALUE:1020>
DISCARD<ITEM:GEAR, XLOC:5, YLOC:1, DESCRIPTION:Thorn armour, SLOT:chest, VALUE:120>
COLLECT<ITEM:GEAR, XLOC:6, YLOC:1, DESCRIPTION:Infinity Pants, SLOT:legs, VALUE:30000>
\end{lstlisting}

\subsection{Empty List}
\quad \textbf{Map}
\begin{lstlisting}
5,4
,,C 200,
,G Vibranium Shield:hands:990,,C 50
M Healing Potion:85,,M Defence Enchantment:360,
,,,
,,G Lightsaber:hands:850,
\end{lstlisting}

\textbf{List}
\begin{lstlisting}

\end{lstlisting}
\pagebreak

\textbf{stderr}
\begin{lstlisting}
File <list file> was empty.
\end{lstlisting}

\subsection{Invalid Direction}
\quad \textbf{Map}
\begin{lstlisting}
5,4
,,C 200,
,G Vibranium Shield:hands:990,,C 50
M Healing Potion:85,,M Defence Enchantment:360,
,,,
,,G Lightsaber:hands:850,
\end{lstlisting}

\textbf{List}
\begin{lstlisting}
LEFT 3
riGhtt 1
DOWN 2
LEFT 5
RIGHT 20
NOrtH 1
DOWN 100
UP 2000
\end{lstlisting}
\pagebreak

\textbf{stderr}
\begin{lstlisting}
Invalid direction
At line 2.
\end{lstlisting}

\subsection{Invalid Distance}

\quad \textbf{Map}
\begin{lstlisting}
5,4
,,C 200,
,G Vibranium Shield:hands:990,,C 50
M Healing Potion:85,,M Defence Enchantment:360,
,,,
,,G Lightsaber:hands:850,
\end{lstlisting}

\textbf{List}
\begin{lstlisting}
DOWN 2
RIGHT 2
DOWn %s
up 0
LEFT 1
UP 3
riGHT 0
RIGHT 2
\end{lstlisting}
\pagebreak

\textbf{stderr}
\begin{lstlisting}
Distance must be an integer
At line 3.
\end{lstlisting}

\subsection{No Space in List}

\quad \textbf{Map}
\begin{lstlisting}
5,4
,,C 200,
,G Vibranium Shield:hands:990,,C 50
M Healing Potion:85,,M Defence Enchantment:360,
,,,
,,G Lightsaber:hands:850,
\end{lstlisting}

\textbf{List}
\begin{lstlisting}
DOWN 2
RIGHT 2
DOWn 2
up 0
LEFT1
UP 3
riGHT 0
RIGHT 1
\end{lstlisting}
\pagebreak

\textbf{stderr}
\begin{lstlisting}
No space
At line 5.
\end{lstlisting}

\subsection{Negative Distance}

\quad \textbf{Map}
\begin{lstlisting}
5,4
,,C 200,
,G Vibranium Shield:hands:990,,C 50
M Healing Potion:85,,M Defence Enchantment:360,
,,,
,,G Lightsaber:hands:850,
\end{lstlisting}

\textbf{List}
\begin{lstlisting}
DOWN 2
RIGHT 2
DOWn 2
up 0
LEFT 1
UP 3
riGHT 0
RIGHT -100
\end{lstlisting}
\pagebreak

\textbf{stderr}
\begin{lstlisting}
Distance must be positive
At line 8.
\end{lstlisting}

\subsection{Floating Point Distance}

\quad \textbf{Map}
\begin{lstlisting}
5,4
,,C 200,
,G Vibranium Shield:hands:990,,C 50
M Healing Potion:85,,M Defence Enchantment:360,
,,,
,,G Lightsaber:hands:850,
\end{lstlisting}

\textbf{List}
\begin{lstlisting}
DOWN 2
RIGHT 2
DOWn 2
up 0
LEFT 1
UP 3
riGHT 0.5
RIGHT 100
\end{lstlisting}
\pagebreak

\textbf{stderr}
\begin{lstlisting}
Distance must be an integer
At line 7.
\end{lstlisting}

\subsection{Empty Map}

\quad \textbf{Map}
\begin{lstlisting}

\end{lstlisting}

\textbf{List}
\begin{lstlisting}
DOWN 2
RIGHT 2
DOWn 2
up 0
LEFT 1
UP 3
riGHT 0
RIGHT 2
\end{lstlisting}
\pagebreak

\textbf{stderr}
\begin{lstlisting}
Incorrect formatting in <map file>, line 1: Expected positive integers <rows>,<cols>
\end{lstlisting}

\subsection{Incorrect Rows}

\quad \textbf{Map}
\begin{lstlisting}
7,3
,g Thorn armour:CheST:120,C 200
,G Vibranium Shield:hands:990,
M Healing Potion:85,,M Defence Enchantment:360
,m Phoenix Blood:291,
,g IDEK_ANYMORE:heaD:21,G Lightsaber:hAnDs:850
c 350,g Crimson Plate:cHeSt:1020,
\end{lstlisting}

\textbf{List}
\begin{lstlisting}
DOWN 2
RIGHT 2
DOWn 2
up 0
LEFT 1
UP 3
riGHT 0
RIGHT 2
\end{lstlisting}
\pagebreak

\textbf{stderr}
\begin{lstlisting}
Incorrect number of rows: read 6, expected 7.
\end{lstlisting}

\subsection{Incorrect Columns}

\quad \textbf{Map}
\begin{lstlisting}
7,3
,g Thorn armour:CheST:120,C 200
,G Vibranium Shield:hands:990,
M Healing Potion:85,,M Defence Enchantment:360
,m Phoenix Blood:291,
,g IDEK_ANYMORE:heaD:21,G Lightsaber:hAnDs:850
c 350,g Crimson Plate:cHeSt:1020
,G Infinity Pants:leGS:30000,
\end{lstlisting}

\textbf{List}
\begin{lstlisting}
DOWN 2
RIGHT 2
DOWn 2
up 0
LEFT 1
UP 3
riGHT 0
RIGHT 2
\end{lstlisting}
\pagebreak

\textbf{stderr}
\begin{lstlisting}
Incorrect number of columns at line 7: expected 3.
\end{lstlisting}

\subsection{Negative Columns}

\quad \textbf{Map}
\begin{lstlisting}
7,-3
,g Thorn armour:CheST:120,C 200
,G Vibranium Shield:hands:990,
M Healing Potion:85,,M Defence Enchantment:360
,m Phoenix Blood:291,
,g IDEK_ANYMORE:heaD:21,G Lightsaber:hAnDs:850
c 350,g Crimson Plate:cHeSt:1020,
,G Infinity Pants:leGS:30000,
\end{lstlisting}

\textbf{List}
\begin{lstlisting}
DOWN 2
RIGHT 2
DOWn 2
up 0
LEFT 1
UP 3
riGHT 0
RIGHT 2
\end{lstlisting}
\pagebreak

\textbf{stderr}
\begin{lstlisting}
Incorrect formatting in <map file>, line 1: Expected positive integers <rows>,<cols>
\end{lstlisting}

\subsection{Invalid Rows}

\quad \textbf{Map}
\begin{lstlisting}
7.5,3
,g Thorn armour:CheST:120,C 200
,G Vibranium Shield:hands:990,
M Healing Potion:85,,M Defence Enchantment:360
,m Phoenix Blood:291,
,g IDEK_ANYMORE:heaD:21,G Lightsaber:hAnDs:850
c 350,g Crimson Plate:cHeSt:1020,
,G Infinity Pants:leGS:30000,
\end{lstlisting}

\textbf{List}
\begin{lstlisting}
DOWN 2
RIGHT 2
DOWn 2
up 0
LEFT 1
UP 3
riGHT 0
RIGHT 2
\end{lstlisting}
\pagebreak

\textbf{stderr}
\begin{lstlisting}
Incorrect formatting in <map file>, line 1: Expected positive integers <rows>,<cols>
\end{lstlisting}

\subsection{Invalid Treasure Type}

\quad \textbf{Map}
\begin{lstlisting}
7,3
,g Thorn armour:CheST:120,C 200
,G Vibranium Shield:hands:990,
M Healing Potion:85,,M Defence Enchantment:360
,m Phoenix Blood:291,
,g IDEK_ANYMORE:heaD:21,f Lightsaber:hAnDs:850
c 350,g Crimson Plate:cHeSt:1020,
,G Infinity Pants:leGS:30000,
\end{lstlisting}

\textbf{List}
\begin{lstlisting}
DOWN 2
RIGHT 2
DOWn 2
up 0
LEFT 1
UP 3
riGHT 0
RIGHT 2
\end{lstlisting}
\pagebreak

\textbf{stderr}
\begin{lstlisting}
F is not a valid treasure type.
At row 5, column 3.
\end{lstlisting}

\subsection{Invalid Slot}

\quad \textbf{Map}
\begin{lstlisting}
7,3
,g Thorn armour:CheST:120,C 200
,G Vibranium Shield:hands:990,
M Healing Potion:85,,M Defence Enchantment:360
,m Phoenix Blood:291,
,g IDEK_ANYMORE:heaD:21,G bow and arrows:feet:850
c 350,g Crimson Plate:cHeSt:1020,
,G Infinity Pants:leGS:30000,
\end{lstlisting}

\textbf{List}
\begin{lstlisting}
DOWN 2
RIGHT 2
DOWn 2
up 0
LEFT 1
UP 3
riGHT 0
RIGHT 2
\end{lstlisting}
\pagebreak

\textbf{stderr}
\begin{lstlisting}
Incorrect formatting. Gear is represented as: "G <detail>:<slot>:<value>"
At row 5, column 3.
\end{lstlisting}

\subsection{Invalid Value}

\quad \textbf{Map}
\begin{lstlisting}
7,3
,g Thorn armour:CheST:120,C 200
,G Vibranium Shield:hands:99.5,
M Healing Potion:85,,M Defence Enchantment:360
,m Phoenix Blood:291,
,g IDEK_ANYMORE:heaD:21,G Lightsaber:hAnDs:850
c 350,g Crimson Plate:cHeSt:1020,
,G Infinity Pants:leGS:30000,
\end{lstlisting}

\textbf{List}
\begin{lstlisting}
DOWN 2
RIGHT 2
DOWn 2
up 0
LEFT 1
UP 3
riGHT 0
RIGHT 2
\end{lstlisting}
\pagebreak

\textbf{stderr}
\begin{lstlisting}
Incorrect formatting. Gear is represented as: "G <detail>:<slot>:<value>"
At row 2, column 2.
\end{lstlisting}

\subsection{Too Many Colons}

\quad \textbf{Map}
\begin{lstlisting}
7,3
,g Thorn armour:CheST:120,C 200
,G Vibranium Shield:hands:990,
M Healing:Potion:85,,M Defence Enchantment:360
,m Phoenix Blood:291,
,g IDEK_ANYMORE:heaD:21,G Lightsaber:hAnDs:850
c 350,g Crimson Plate:cHeSt:1020,
,G Infinity Pants:leGS:30000,
\end{lstlisting}

\textbf{List}
\begin{lstlisting}
DOWN 2
RIGHT 2
DOWn 2
up 0
LEFT 1
UP 3
riGHT 0
RIGHT 2
\end{lstlisting}
\pagebreak

\textbf{stderr}
\begin{lstlisting}
Incorrect formatting. Magic items are represented as: "M <detail>:<value>"
At row 3, column 1.
\end{lstlisting}

\subsection{Too Little Colons}

\quad \textbf{Map}
\begin{lstlisting}
7,3
,g Thorn armour:CheST:120,C 200
,G Vibranium Shield:hands:990,
M Healing Potion:85,,M Defence Enchantment:360
,m Phoenix Blood:291,
,g IDEK_ANYMORE:heaD:21,G Lightsaber:hAnDs:850
c 350,g Crimson Plate:cHeSt:1020,
,G Infinity Pants leGS:30000,
\end{lstlisting}

\textbf{List}
\begin{lstlisting}
DOWN 2
RIGHT 2
DOWn 2
up 0
LEFT 1
UP 3
riGHT 0
RIGHT 2
\end{lstlisting}
\pagebreak

\textbf{stderr}
\begin{lstlisting}
Incorrect formatting. Gear is represented as: "G <detail>:<slot>:<value>"
At row 7, column 2.
\end{lstlisting}

\subsection{No Space in Map}

\quad \textbf{Map}
\begin{lstlisting}
7,3
,g Thorn armour:CheST:120,C 200
,G Vibranium Shield:hands:990,
MHealing Potion:85,,M Defence Enchantment:360
,m Phoenix Blood:291,
,g IDEK_ANYMORE:heaD:21,G Lightsaber:hAnDs:850
c 350,g Crimson Plate:cHeSt:1020,
,G Infinity Pants:leGS:30000,
\end{lstlisting}

\textbf{List}
\begin{lstlisting}
DOWN 2
RIGHT 2
DOWn 2
up 0
LEFT 1
UP 3
riGHT 0
RIGHT 2
\end{lstlisting}
\pagebreak

\textbf{stderr}
\begin{lstlisting}
Incorrect formatting. Magic items are represented as: "M <detail>:<value>"
At row 3, column 1.
\end{lstlisting}

\end{document}
